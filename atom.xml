<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Goto&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.i4ww.com/"/>
  <updated>2018-07-10T03:32:50.000Z</updated>
  <id>http://www.i4ww.com/</id>
  
  <author>
    <name>goto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP新的垃圾回收机制</title>
    <link href="http://www.i4ww.com/2018/03/07/PHP%E6%96%B0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.i4ww.com/2018/03/07/PHP新的垃圾回收机制/</id>
    <published>2018-03-07T14:28:02.000Z</published>
    <updated>2018-07-10T03:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在阅读本篇博文之前，建议先了解一下: <a href="/2018/03/06/深入理解PHP内核之ZVAL/">PHP内核之ZVAL</a><br>PHP是一门托管型语言，所以在写PHP代码时无需手动处理内存的分配和释放，也就是说PHP自身实现了垃圾自动回收(GC).<br>在PHP官方你可以看到关于GC的介绍: <a href="http://php.net/manual/zh/features.gc.php" rel="external nofollow noopener noreferrer" target="_blank">传送</a></p><h1 id="PHP5-2中的垃圾回收算法"><a href="#PHP5-2中的垃圾回收算法" class="headerlink" title="PHP5.2中的垃圾回收算法"></a>PHP5.2中的垃圾回收算法</h1><p> 在php5.3之前，PHP使用的内存回收算法是大名鼎鼎的<a href="https://en.wikipedia.org/wiki/Reference_counting" rel="external nofollow noopener noreferrer" target="_blank">Reference counting</a>(引用计数)</p><a id="more"></a><h2 id="Reference-counting-的实现原理"><a href="#Reference-counting-的实现原理" class="headerlink" title="Reference counting 的实现原理"></a>Reference counting 的实现原理</h2><p>为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为 1(因为此时一定有一个变量引用了该对象)。以后每有一个新变量引用此内存对象（如赋值操作 $a = $b），计数器加 1，而每当减少一个引用此内存对象的变量（如 unset($a)），计数器减 1。当垃圾回收机制运作的时候，将所有计数器为 0 的内存对象销毁并回收其占用的内存。</p><p>在PHP5.2中内存对象就是zval, 计数器就是 zval 的 refcount (PHP5.3之后改成 refcount__gc)， 使用 xdebug 拓展的xdebug_debug_zval() 方法可以看到 refcount 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">unset($b);</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><p>输出结果<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">b: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure></p><p> 由上而的输出结果到知，当把$a赋值给$b时，refcount 会加 1, 因为两个变量都指向同一个zval, 而不是新增一个zval, 也就是cow(写时复制)。</p><p> 当对$b使用unset()时，refcount 会减 1, 因为现在只有$a指向这个zval。</p><p> Reference counting (引用计数) 非常的简单，但也有一个致命问题，那就是环状引用时会造成内存泄露。</p><p> 如下是一个典型例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = array( &apos;one&apos; );</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br></pre></td></tr></table></figure><p> 输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 图示:<br> <img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-loop-array.png" alt=""></p><p> 上面的 … 是发生了递归调用, a 的变量容器中 refcount 的值由于有两次引用的存在所以为 2。</p><p> 此时对 $a 调用 unset()，将从符号表中删除这个符号，同时 refcount 值也减 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(refcount=1, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=1, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-leak-array.png" alt=""><br>因为 refcount = 1 不等于 0，所以它不会被当作垃圾回收。但同时在符号表中找不到哪个符号指向这个 zval，导致也没有办法手动清除。最终的导致在这个脚本结束之前，这个zval结构体会一直占用着内存，导致内存泄漏。</p><p>由于 Reference Counting 的这个缺陷，PHP5.3 改进了垃圾回收算法。</p><h1 id="PHP5-3中的垃圾回收算法"><a href="#PHP5-3中的垃圾回收算法" class="headerlink" title="PHP5.3中的垃圾回收算法"></a>PHP5.3中的垃圾回收算法</h1><p>PHP5.3 的垃圾回收算法是在引用计数的基础上，添加了一种同步回收算法，这个算法由IBM的工程师在论文<a href="https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Cycle Collection in Reference Counted Systems</a> 中提出。</p><p>具体实现原理:</p><p>首先 PHP 会分配一个固定大小的“根缓冲区”，这个缓冲区用于存放固定数量的 zval（默认是10,000），如果需要修改则需要修改源代码 Zend/zend_gc.c 中的常量 GC_ROOT_BUFFER_MAX_ENTRIES 然后重新编译。</p><p>这个根缓冲区中存放的是 可能根（possible roots)，就是可能发生内存泄露的 zval。当根缓冲区满了的时候（或者手动调用 gc_collect_cycle() 函数时），PHP 就会执行垃圾回收。</p><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png" alt=""></p><h2 id="步骤-A"><a href="#步骤-A" class="headerlink" title="步骤 A"></a>步骤 A</h2><p> 为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。</p><h2 id="步骤-B"><a href="#步骤-B" class="headerlink" title="步骤 B"></a>步骤 B</h2><p> 模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰。</p><h2 id="步骤-C"><a href="#步骤-C" class="headerlink" title="步骤 C"></a>步骤 C</h2><p> 模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，</p><h2 id="步骤-D"><a href="#步骤-D" class="headerlink" title="步骤 D"></a>步骤 D</h2><p> 清空根缓冲区中的所有根，然后销毁所有 refcount 为 0 的 zval，并收回其内存，这才是真实删除的过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>并不是每次 refcount 减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。</li><li>解决了循环引用导致的内存泄露问题。</li><li>整体上可以总将内存泄露保持在一个阈值以下（与缓冲区的大小有关)。</li></ul><h1 id="新的垃圾回收机制总结"><a href="#新的垃圾回收机制总结" class="headerlink" title="新的垃圾回收机制总结"></a>新的垃圾回收机制总结</h1><ul><li>如果发现一个zval容器中的refcount在增加，说明不是垃圾</li><li>如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收</li><li>如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象</li><li>当缓冲区满时，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在阅读本篇博文之前，建议先了解一下: &lt;a href=&quot;/2018/03/06/深入理解PHP内核之ZVAL/&quot;&gt;PHP内核之ZVAL&lt;/a&gt;&lt;br&gt;PHP是一门托管型语言，所以在写PHP代码时无需手动处理内存的分配和释放，也就是说PHP自身实现了垃圾自动回收(GC).&lt;br&gt;在PHP官方你可以看到关于GC的介绍: &lt;a href=&quot;http://php.net/manual/zh/features.gc.php&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;PHP5-2中的垃圾回收算法&quot;&gt;&lt;a href=&quot;#PHP5-2中的垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;PHP5.2中的垃圾回收算法&quot;&gt;&lt;/a&gt;PHP5.2中的垃圾回收算法&lt;/h1&gt;&lt;p&gt; 在php5.3之前，PHP使用的内存回收算法是大名鼎鼎的&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Reference counting&lt;/a&gt;(引用计数)&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.i4ww.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.i4ww.com/tags/PHP/"/>
    
      <category term="Zend" scheme="http://www.i4ww.com/tags/Zend/"/>
    
      <category term="GC" scheme="http://www.i4ww.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>深入理解PHP内核之ZVAL</title>
    <link href="http://www.i4ww.com/2018/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%86%85%E6%A0%B8%E4%B9%8BZVAL/"/>
    <id>http://www.i4ww.com/2018/03/06/深入理解PHP内核之ZVAL/</id>
    <published>2018-03-06T15:55:56.000Z</published>
    <updated>2018-07-10T03:33:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP是一种弱类型语言，但是弱类型并不代表PHP变量就没有类型区分</p><p>PHP的类型有8种</p><ul><li>标量类型：boolen(布尔)，integer(整型)，float(浮点)，string(字符)</li><li>复合类型：array(数组)，object(对象)</li><li>特殊类型：resource(资源) null</li></ul><a id="more"></a><p>PHP可以不声明变量类型，可以在运行时直接赋值。并且在运行期间可以由一种类型转换成另一种类型。</p><p>如下例，没有声明的情况下，$variable 可以赋任意类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$variable = 0;</span><br><span class="line">$variable = &apos;hello world.&apos;;</span><br><span class="line">$variable = true;</span><br></pre></td></tr></table></figure></p><p>在PHP引擎内，变量都是用一个结构体来表示。</p><p>这个结构体具体代码在: <a href="https://github.com/php/php-src/blob/PHP-5.6.34/Zend/zend.h" rel="external nofollow noopener noreferrer" target="_blank">点击传送</a></p><p>ZVAL 基本结构为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">/* Variable information */</span><br><span class="line">zvalue_value value; /* 存储变量的值 */</span><br><span class="line">zend_uint refcount__gc; /* 引用计数 */</span><br><span class="line">zend_uchar type; /* 变量的类型 */</span><br><span class="line">zend_uchar is_ref__gc; /* 是否为引用 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="zval-value-value"><a href="#zval-value-value" class="headerlink" title="zval_value value"></a>zval_value value</h3><pre><code>这里就是变量的实际值，类型是一个 zvalue_value 联合体。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">long lval;/* long value */</span><br><span class="line">double dval;/* double value */</span><br><span class="line">struct &#123;</span><br><span class="line">char *val;</span><br><span class="line">int len;</span><br><span class="line">&#125; str;</span><br><span class="line">HashTable *ht;/* hash table value */</span><br><span class="line">zend_object_value obj;</span><br><span class="line">zend_ast *ast;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><h3 id="zend-uint-refcount-gc"><a href="#zend-uint-refcount-gc" class="headerlink" title="zend_uint refcount__gc"></a>zend_uint refcount__gc</h3><pre><code>实际是一个计数器，用来保存有多少变量指向该zval。在变量生成时，会置为1，也就是说 refcount__gc = 1对变量进行操作会改变它的值。如 $a = $b 会使 refcount 加 1，而 unset() 操作会减 1</code></pre><h3 id="zend-uchar-type"><a href="#zend-uchar-type" class="headerlink" title="zend_uchar type"></a>zend_uchar type</h3><p> 这个字段表示变量的类型，前面说过 PHP 有8种类型，在 PHP zend 引擎中，对应下面的宏</p><p> 该type字段会决定上面 zval_value 联合体储存的方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define IS_NULL0</span><br><span class="line">#define IS_LONG1</span><br><span class="line">#define IS_DOUBLE2</span><br><span class="line">#define IS_BOOL3</span><br><span class="line">#define IS_ARRAY4</span><br><span class="line">#define IS_OBJECT5</span><br><span class="line">#define IS_STRING6</span><br><span class="line">#define IS_RESOURCE7</span><br><span class="line">#define IS_CONSTANT8</span><br><span class="line">#define IS_CONSTANT_AST9</span><br><span class="line">#define IS_CALLABLE10</span><br></pre></td></tr></table></figure><h3 id="zend-uchar-is-ref-gc"><a href="#zend-uchar-is-ref-gc" class="headerlink" title="zend_uchar is_ref__gc"></a>zend_uchar is_ref__gc</h3><pre><code>标志是否为引用,当使用 &amp; 对一个变量操作时,如 $a = &amp;$b, is_ref__gc 会被设置为1。</code></pre><h1 id="zval如何在PHP中运行"><a href="#zval如何在PHP中运行" class="headerlink" title="zval如何在PHP中运行"></a>zval如何在PHP中运行</h1><h3 id="我们在创建一个PHP变量时实际上在PHP中是创建了一个zval"><a href="#我们在创建一个PHP变量时实际上在PHP中是创建了一个zval" class="headerlink" title="我们在创建一个PHP变量时实际上在PHP中是创建了一个zval"></a>我们在创建一个PHP变量时实际上在PHP中是创建了一个zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码需要安装 xdebug 扩展</span><br><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h3 id="对应上面的zval结构体，也就是"><a href="#对应上面的zval结构体，也就是" class="headerlink" title="对应上面的zval结构体，也就是"></a>对应上面的zval结构体，也就是</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = &apos;hello world&apos;;</span><br><span class="line">refcount__gc = 1;</span><br><span class="line">type =  IS_STRING;</span><br><span class="line">is_ref__gc = 0;</span><br></pre></td></tr></table></figure><h2 id="我们把-a赋值给另一个变量时，会增加zval的refcount-gc"><a href="#我们把-a赋值给另一个变量时，会增加zval的refcount-gc" class="headerlink" title="我们把$a赋值给另一个变量时，会增加zval的refcount__gc"></a>我们把$a赋值给另一个变量时，会增加zval的refcount__gc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">xdebug_debug_zval(&apos;b&apos;);</span><br></pre></td></tr></table></figure><h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">b: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h3 id="可以看到-a和-b的结构是一样的-它们都指向同一个zval"><a href="#可以看到-a和-b的结构是一样的-它们都指向同一个zval" class="headerlink" title="可以看到$a和$b的结构是一样的,它们都指向同一个zval"></a>可以看到$a和$b的结构是一样的,它们都指向同一个zval</h3><h2 id="使用unset时"><a href="#使用unset时" class="headerlink" title="使用unset时"></a>使用unset时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">unset($b);</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输入结果"><a href="#输入结果" class="headerlink" title="输入结果"></a>输入结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h2 id="使用-amp-时"><a href="#使用-amp-时" class="headerlink" title="使用 &amp; 时"></a>使用 &amp; 时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输入结果-1"><a href="#输入结果-1" class="headerlink" title="输入结果"></a>输入结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  在 PHP7 中，zval结构体发生了重大变化，有兴趣的可以参考 <a href="https://github.com/laruence/php7-internal/blob/master/zval.md" rel="external nofollow noopener noreferrer" target="_blank">鸟哥-深入理解PHP7之zval</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP是一种弱类型语言，但是弱类型并不代表PHP变量就没有类型区分&lt;/p&gt;
&lt;p&gt;PHP的类型有8种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标量类型：boolen(布尔)，integer(整型)，float(浮点)，string(字符)&lt;/li&gt;
&lt;li&gt;复合类型：array(数组)，object(对象)&lt;/li&gt;
&lt;li&gt;特殊类型：resource(资源) null&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.i4ww.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://www.i4ww.com/tags/PHP/"/>
    
      <category term="Zend" scheme="http://www.i4ww.com/tags/Zend/"/>
    
      <category term="Zval" scheme="http://www.i4ww.com/tags/Zval/"/>
    
  </entry>
  
  <entry>
    <title>三种常见单例模式实现</title>
    <link href="http://www.i4ww.com/2018/03/06/%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.i4ww.com/2018/03/06/三种常见单例模式实现/</id>
    <published>2018-03-06T14:17:31.000Z</published>
    <updated>2018-07-10T03:32:55.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下面列举了三种-懒汉式-饿汉式-登记式"><a href="#下面列举了三种-懒汉式-饿汉式-登记式" class="headerlink" title="下面列举了三种: 懒汉式 饿汉式 登记式"></a>下面列举了三种: 懒汉式 饿汉式 登记式</h3><a id="more"></a><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        if (self::$instance === null) &#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * php中是不允许这样的，这里只做示例使用</span><br><span class="line">  */</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * php中是不允许的这样的，这里只做示例使用</span><br><span class="line">  */</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class Holder</span><br><span class="line">    &#123;</span><br><span class="line">        private static final Singleton SINGLETON = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        return Holder.SINGLETON;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下面列举了三种-懒汉式-饿汉式-登记式&quot;&gt;&lt;a href=&quot;#下面列举了三种-懒汉式-饿汉式-登记式&quot; class=&quot;headerlink&quot; title=&quot;下面列举了三种: 懒汉式 饿汉式 登记式&quot;&gt;&lt;/a&gt;下面列举了三种: 懒汉式 饿汉式 登记式&lt;/h3&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.i4ww.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式" scheme="http://www.i4ww.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="懒汉式" scheme="http://www.i4ww.com/tags/%E6%87%92%E6%B1%89%E5%BC%8F/"/>
    
      <category term="饿汉式" scheme="http://www.i4ww.com/tags/%E9%A5%BF%E6%B1%89%E5%BC%8F/"/>
    
      <category term="登记式" scheme="http://www.i4ww.com/tags/%E7%99%BB%E8%AE%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的 Generator (生成器)</title>
    <link href="http://www.i4ww.com/2018/03/05/ES6%E7%9A%84Generator/"/>
    <id>http://www.i4ww.com/2018/03/05/ES6的Generator/</id>
    <published>2018-03-05T13:24:57.000Z</published>
    <updated>2018-07-10T03:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Generator 是 ES6 标准中引入的一个新的数据类型。</p><a id="more"></a><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>先看看具体怎么使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* demo(i) &#123;</span><br><span class="line">yield i++;</span><br><span class="line">yield i++;</span><br><span class="line">return  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var de = demo(1);</span><br><span class="line"></span><br><span class="line">de.next(); // &#123;value: 1, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: 2, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: 3, done: true&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看出:</p><pre><code>1. Generator 和 函数 很像。2. Generator 定义 function* 比 函数 多出一个 * 号。3. Generator 调用后返回的结果 (迭代器对象) 需要赋值给一个变量4. Generator 返回的结果可以多次调用。</code></pre><p>其实上面的代码就是定义了一个以 demo 命名的 Generator (生成器)。</p><p>调用后会返回一个对象，这个对象我们称它为 迭代器。</p><p>每次调用这个返回的 迭代器 的 next 方法后，会执行第一条 yield (委托)。</p><p>并在这里暂停 (退出并保留上下文，下次进入时继续向下运行)，</p><p>然后返回一个对象，这个对象包含 一个 value (yield 后面的运算结果) 和 一个 done (迭代器是否完成)</p><p>根据上面的执行结果可以看出，每调用一次 next，都会执行一次 yield。</p><p>当遇到 return 时，返回对象的 done 就变成了 true, 此时就退出了 Generator。</p><h1 id="next-方法"><a href="#next-方法" class="headerlink" title="next 方法"></a>next 方法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function* demo() &#123;</span><br><span class="line">let i = yield &apos;one&apos;;</span><br><span class="line">return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var de = demo();</span><br><span class="line"></span><br><span class="line">let obj = de.next(); // &#123;value: &quot;one&quot;, done: false&#125;</span><br><span class="line"></span><br><span class="line">de.next(&quot;test:&quot; + obj.value); // &#123;value: &quot;test:one&quot;, done: true&#125;</span><br></pre></td></tr></table></figure><p>next 方法是可以传递参数的，这个参数将作为 上次暂停的 yield  的返回值。</p><h1 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h1><p>yield 我们知道是怎么一回事了，那 yield* 又是什么？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function* demo() &#123;</span><br><span class="line">yield &apos;one&apos;;</span><br><span class="line">yield foo();</span><br><span class="line">yield &apos;four&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* foo() &#123;</span><br><span class="line">yield &apos;two&apos;;</span><br><span class="line">yield &apos;three&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var de = demo();</span><br><span class="line"></span><br><span class="line">de.next(); // &#123;value: &quot;one&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: foo, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: &quot;four&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>调用一个 demo 生成器，执行完第一条 yield ‘one’ 后 第二条 yield foo() 调用另一个生成器。</p><p>结果发现 yield foo() 并没有去调用 foo() 生成器 中的 yield ‘two’</p><p>这是因为 yield 只会返回右边运算的值，而 foo() 返回的是一个 迭代器，所以这里的 value 会是 foo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// foo() 返回一个 迭代器</span><br><span class="line"></span><br><span class="line">foo(); // foo &#123;&lt;suspended&gt;&#125;</span><br></pre></td></tr></table></figure><p>我们改用 yield* 再试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function* demo() &#123;</span><br><span class="line">yield &apos;one&apos;;</span><br><span class="line">yield* foo();</span><br><span class="line">yield &apos;four&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function* foo() &#123;</span><br><span class="line">yield &apos;two&apos;;</span><br><span class="line">yield &apos;three&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var de = demo();</span><br><span class="line"></span><br><span class="line">de.next(); // &#123;value: &quot;one&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: &quot;two&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: &quot;three&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: &quot;four&quot;, done: false&#125;</span><br><span class="line">de.next(); // &#123;value: undefined, done: true&#125;</span><br></pre></td></tr></table></figure><p>很多人用 Generator 来处理异步编程，但它的本质是其实是协程，下一次我们再具体说明。</p><p>关于如何使用 Generator 来处理异步编程，请看我的另一篇文章：</p><ul><li><a href="/2018/03/05/js异步流程控制">js异步流程控制</a></li></ul><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Generator 是 ES6 标准中引入的一个新的数据类型。&lt;/p&gt;
    
    </summary>
    
      <category term="Js" scheme="http://www.i4ww.com/categories/Js/"/>
    
    
      <category term="Node" scheme="http://www.i4ww.com/tags/Node/"/>
    
      <category term="Js" scheme="http://www.i4ww.com/tags/Js/"/>
    
      <category term="ES6" scheme="http://www.i4ww.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Js异步流程控制</title>
    <link href="http://www.i4ww.com/2018/03/05/js%E5%BC%82%E6%AD%A5%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://www.i4ww.com/2018/03/05/js异步流程控制/</id>
    <published>2018-03-05T12:35:50.000Z</published>
    <updated>2018-07-10T03:32:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>目前 Js 流程控制技术多种多样，而async/await是es7的新标准<br>那像 callback, events, promise，generator，co 又是什么样，为什么更推荐使用async呢？</p><a id="more"></a><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>先来看看传统的回调，这也是最简单最容易理解的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function sleep(callback) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">        console.log(&apos;执行到这里了&apos;);</span><br><span class="line">callback(&apos;hello world&apos;);</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep(function(message) &#123;</span><br><span class="line">console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 执行结果：</span><br><span class="line"></span><br><span class="line">// 执行到这里了</span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure><p>上面的代码比较容易理解，调用sleep, 把匿名函数作为参数传递出去，当sleep执行完成后调用回调参数</p><p>但如果有多层调用就会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sleep(function(message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line"></span><br><span class="line">    sleep(function(message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line"></span><br><span class="line">    sleep(function(message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这也就是所谓的 “回调地狱（callback hell）”。</p><p>很明显，这种写法层级嵌套很深，比较反人类，维护起来相当麻烦，出错了很难以排查，</p><h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>下面代码采用 nodejs 的 events 模块，该模块可以实现事件绑定触发 (事件机制其实是一种观察者模式)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function sleep() &#123;</span><br><span class="line">    var emitter = new require(&apos;events&apos;)();</span><br><span class="line">    emitter.emit(&apos;one&apos;, &apos;回调: 1&apos;);</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">    emitter.emit(&apos;two&apos;, &apos;回调: 2&apos;);</span><br><span class="line">        emitter.emit(&apos;done&apos;, &apos;完成&apos;);</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var emit = sleep();</span><br><span class="line">emit.on(&apos;one&apos;,function (message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emit.on(&apos;two&apos;,function (message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">emit.on(&apos;done&apos;,function (message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 执行结果：</span><br><span class="line"></span><br><span class="line">// 回调: 1</span><br><span class="line">// 回调: 2</span><br><span class="line">// 完成</span><br></pre></td></tr></table></figure><p>使用 events 的好处是可以比较方便的添加多个回调，有利于实现模块化</p><p>但并没有解决回调嵌套的问题</p><p>如果有多层嵌套，需要在emit.on匿名函数里添加，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">emit.on(&apos;done&apos;, function() &#123;</span><br><span class="line">var emit2 = sleep();</span><br><span class="line">emit2.on(&apos;done&apos;,function (message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>而且整个程序都要变成事件驱动型，运行流程会变得不清晰。</p><h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><p>Promise 对象是 CommonJS 提出的一种规范，目的是为异步编程提供统一接口。</p><p>并且 ES6 原生提供了 Promise 对象。</p><p>直接上代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var delay = function(ret) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">if (ret) &#123;</span><br><span class="line">resolve(&apos;delay 执行完了&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">reject(&apos;这是出错信息.&apos;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var callback = function(message) &#123;</span><br><span class="line">    console.log(message);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var error = function(error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">delay(true).then(callback).catch(error); // delay 执行完了</span><br><span class="line"></span><br><span class="line">delay(false).then(callback).catch(error); // 这是出错信息.</span><br></pre></td></tr></table></figure><p>使用 promise 后回调函数变成了链式写法，程序的运行流程可以看得很清楚，而且有一整套的配套方法实现许多强大的功能。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 实现多个回调</span><br><span class="line">delay().then(callback1).then(callback2);</span><br><span class="line"></span><br><span class="line">// 发生错误时</span><br><span class="line">delay().catch(error);</span><br></pre></td></tr></table></figure><p>这种写法的缺点是编写和理解比较困难。</p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p> Generator(生成器) 是 ES6 的新特性，具体用法请看我的另一篇文章 </p><ul><li><a href="/2018/03/05/ES6的Generator">ES6 的 Generator (生成器)</a></li></ul><h1 id="co"><a href="#co" class="headerlink" title="co"></a>co</h1><p>那么怎么利用 Generator 进行异步流程控制呢？</p><p>先实现一个 co 函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 先定义一个 sleep 函数，这个函数的作用是返回一个匿名函数</span><br><span class="line">function sleep(ms) &#123;</span><br><span class="line">return function(callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">callback(&apos;test&apos;);</span><br><span class="line">&#125;, ms);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 把一个生成器作为参数传递给 co</span><br><span class="line">co(function* ()&#123;</span><br><span class="line">    var now = Date.now();</span><br><span class="line">    var i = yield sleep(100);</span><br><span class="line">    console.log(Date.now() - now); // 100 (因为执行效率的原因可能会大于100)</span><br><span class="line">console.log(i); // test</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">function co(func) &#123;</span><br><span class="line"></span><br><span class="line">    // 执行 生成器 得到 迭代器</span><br><span class="line">    var gen = func();</span><br><span class="line"></span><br><span class="line">    //调用下面的 next 方面</span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    function next(arg) &#123;</span><br><span class="line"></span><br><span class="line">        // 执行 迭代器</span><br><span class="line">        var ret = gen.next(arg);</span><br><span class="line"></span><br><span class="line">        // 生成器结束直接返回</span><br><span class="line">        if (ret.done) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 执行回调</span><br><span class="line">        // 这里的 ret.value 就是上面的 sleep 返回的 匿名函数</span><br><span class="line">        if (typeof ret.value == &apos;function&apos;) &#123;</span><br><span class="line">            ret.value(function() &#123;</span><br><span class="line"></span><br><span class="line">            // 当 异步操作 (这里是上面的setTimeout) 完成后</span><br><span class="line">            // 递归调用 next，并携带上参数</span><br><span class="line">                next.apply(this, arguments);</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 Promise、generator 和 co 结合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function co(gen) &#123;</span><br><span class="line">    var iterator = gen(); </span><br><span class="line"></span><br><span class="line">    next();</span><br><span class="line"></span><br><span class="line">    function next(arg) &#123;</span><br><span class="line">        var ret = iterator.next(arg);</span><br><span class="line">        if (ret.done) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (typeof ret.value == &apos;object&apos;) &#123;</span><br><span class="line">            ret.value.then(next).catch(function(error) &#123;</span><br><span class="line">                next(iterator.throw(error));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var delay = function(ret) &#123;</span><br><span class="line">return new Promise(function(resolve, reject) &#123;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">if (ret) &#123;</span><br><span class="line">resolve(&apos;delay 执行完了&apos;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">reject(&apos;这是出错信息.&apos;);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var gen = function* () &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var one = yield delay(true);</span><br><span class="line">console.log(one);</span><br><span class="line">var two = yield delay(false);</span><br><span class="line">console.log(two);</span><br><span class="line">&#125; catch(error) &#123;</span><br><span class="line">console.log(&apos;出错了：&apos; + error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen)</span><br><span class="line"></span><br><span class="line">// 执行结果 </span><br><span class="line"></span><br><span class="line">// delay 执行完了</span><br><span class="line">// 出错了：这是出错信息.</span><br></pre></td></tr></table></figure><p>上面仅仅是一个简单的 co 实现方式，想体验更加强大的 co，可以去看看下面 TJ 大神开发的 co 模块</p><ul><li><a href="https://www.npmjs.com/package/co" rel="external nofollow noopener noreferrer" target="_blank">co模块</a></li></ul><p>ps: co (coroutine) 即协同程序。</p><h1 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h1><p>async/await 是es7的新标准，可以说是异步流程控制的终极解决方案，它使用起来非常简单，而且不需要知道底层的运行原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 把上面的例子拿过来</span><br><span class="line"></span><br><span class="line">var gen = function* () &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var one = yield delay(true);</span><br><span class="line">console.log(one);</span><br><span class="line">var two = yield delay(false);</span><br><span class="line">console.log(two);</span><br><span class="line">&#125; catch(error) &#123;</span><br><span class="line">console.log(&apos;出错了：&apos; + error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">co(gen)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 上面的代码，改用 async/await 可以写成这样</span><br><span class="line"></span><br><span class="line">var test = async function() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">var one = await delay(true);</span><br><span class="line">console.log(one);</span><br><span class="line">var two = await delay(false);</span><br><span class="line">console.log(two);</span><br><span class="line">&#125; catch(error) &#123;</span><br><span class="line">console.log(&apos;出错了：&apos; + error);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line"></span><br><span class="line">// 执行结果 </span><br><span class="line"></span><br><span class="line">// delay 执行完了</span><br><span class="line">// 出错了：这是出错信息.</span><br></pre></td></tr></table></figure><p>其实经过比较就会发现，async 就是将 Generator 函数的星号（*）换成 async，将 yield 换成 await。</p><p>也就是说 async/await 仅仅是 Generator/yield 的一个语法糖罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h1&gt;&lt;p&gt;目前 Js 流程控制技术多种多样，而async/await是es7的新标准&lt;br&gt;那像 callback, events, promise，generator，co 又是什么样，为什么更推荐使用async呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Js" scheme="http://www.i4ww.com/categories/Js/"/>
    
    
      <category term="Node" scheme="http://www.i4ww.com/tags/Node/"/>
    
      <category term="Js" scheme="http://www.i4ww.com/tags/Js/"/>
    
      <category term="ES7" scheme="http://www.i4ww.com/tags/ES7/"/>
    
  </entry>
  
  <entry>
    <title>多版本并发控制的机制与原理</title>
    <link href="http://www.i4ww.com/2018/03/05/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://www.i4ww.com/2018/03/05/多版本并发控制的机制与原理/</id>
    <published>2018-03-05T11:21:05.000Z</published>
    <updated>2018-07-10T03:32:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h1><ul><li>MVCC （Mutli Version Concurreny Control）既 多版本并发控制，也叫 一致性非锁定读，实现原理其它就是使用快照实现写时复制 (Copy On Write)</li></ul><h1 id="使用MVCC的好处"><a href="#使用MVCC的好处" class="headerlink" title="使用MVCC的好处"></a>使用MVCC的好处</h1><ul><li><p>消除锁的开销：传统的数据库保证数据一致性是对数据进行加锁操作，但加锁必然会产生开销，使用MVCC能够避免对数据加锁。</p></li><li><p>提高并发：在保证了数据的ACID的同时，实现了 读读 、读写、写读 的并发。</p></li></ul><a id="more"></a><h1 id="InnoDB如何实现MVCC"><a href="#InnoDB如何实现MVCC" class="headerlink" title="InnoDB如何实现MVCC"></a>InnoDB如何实现MVCC</h1><ul><li>MySql InnoDB MVCC主要是为事务的 可重复读 隔离级别服务的，在此隔离级别下，进程间数据相互隔离。</li><li>为了实现MVCC，InnoDB引擎会对每一行都加上两个隐藏的字段，一个字段用来存储行被更新的时间戳，另一字段存储行被删除的时间戳 （这里的时间戳都是逻辑时间戳）。事务在开始时，InnoDB引擎会给该事务一个递增的版本号（也就是上面说的逻辑时间戳），在该事务中，InnoDB会把每一条语句的版本号和这条语句遇到的行版本进行比对，然后结合不同的隔离级别，来决定是否返回该行。</li></ul><h1 id="MVCC的缺点："><a href="#MVCC的缺点：" class="headerlink" title="MVCC的缺点："></a>MVCC的缺点：</h1><ul><li>为了实现多版本，InnoDB需要维护额外的隐藏字段，以及清理不需要的行版本，会带来额外开销。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><pre><code>MySql技术内幕</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-MVCC&quot;&gt;&lt;a href=&quot;#什么是-MVCC&quot; class=&quot;headerlink&quot; title=&quot;什么是 MVCC&quot;&gt;&lt;/a&gt;什么是 MVCC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MVCC （Mutli Version Concurreny Control）既 多版本并发控制，也叫 一致性非锁定读，实现原理其它就是使用快照实现写时复制 (Copy On Write)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;使用MVCC的好处&quot;&gt;&lt;a href=&quot;#使用MVCC的好处&quot; class=&quot;headerlink&quot; title=&quot;使用MVCC的好处&quot;&gt;&lt;/a&gt;使用MVCC的好处&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消除锁的开销：传统的数据库保证数据一致性是对数据进行加锁操作，但加锁必然会产生开销，使用MVCC能够避免对数据加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高并发：在保证了数据的ACID的同时，实现了 读读 、读写、写读 的并发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.i4ww.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql" scheme="http://www.i4ww.com/tags/MySql/"/>
    
      <category term="InnoDB" scheme="http://www.i4ww.com/tags/InnoDB/"/>
    
      <category term="MVCC" scheme="http://www.i4ww.com/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>记一次在Docker容器中crontab不执行的问题</title>
    <link href="http://www.i4ww.com/2018/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E4%B8%ADcrontab%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.i4ww.com/2018/02/17/记一次在Docker容器中crontab不执行的问题/</id>
    <published>2018-02-17T10:38:20.000Z</published>
    <updated>2018-07-10T03:33:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决"><a href="#在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决" class="headerlink" title="在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决"></a>在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决</h3><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 进入容器</span><br><span class="line">$ vim /etc/pam.d/crond</span><br><span class="line">account    required   pam_access.so</span><br><span class="line">account    include    password-auth</span><br><span class="line">#session    required   pam_loginuid.so  #注释此行</span><br><span class="line">session    include    password-auth</span><br><span class="line">auth       include    password-auth</span><br></pre></td></tr></table></figure><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><ul><li>不要在单一容器中运行超过一个进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot;&gt;&lt;a href=&quot;#在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot; class=&quot;headerlink&quot; title=&quot;在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot;&gt;&lt;/a&gt;在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="http://www.i4ww.com/categories/docker/"/>
    
    
      <category term="docker" scheme="http://www.i4ww.com/tags/docker/"/>
    
      <category term="crontab" scheme="http://www.i4ww.com/tags/crontab/"/>
    
  </entry>
  
</feed>
