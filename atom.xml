<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Goto&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.i4ww.com/"/>
  <updated>2018-03-08T01:18:49.000Z</updated>
  <id>http://www.i4ww.com/</id>
  
  <author>
    <name>goto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP新的垃圾回收机制</title>
    <link href="http://www.i4ww.com/2018/03/07/PHP%E6%96%B0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://www.i4ww.com/2018/03/07/PHP新的垃圾回收机制/</id>
    <published>2018-03-07T14:28:02.000Z</published>
    <updated>2018-03-08T01:18:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在阅读本篇博文之前，建议先了解一下: <a href="/2018/03/06/深入理解PHP内核之ZVAL/">PHP内核之ZVAL</a><br>PHP是一门托管型语言，所以在写PHP代码时无需手动处理内存的分配和释放，也就是说PHP自身实现了垃圾自动回收(GC).<br>在PHP官方你可以看到关于GC的介绍: <a href="http://php.net/manual/zh/features.gc.php" rel="external nofollow noopener noreferrer" target="_blank">传送</a></p><h1 id="PHP5-2中的垃圾回收算法"><a href="#PHP5-2中的垃圾回收算法" class="headerlink" title="PHP5.2中的垃圾回收算法"></a>PHP5.2中的垃圾回收算法</h1><p> 在php5.3之前，PHP使用的内存回收算法是大名鼎鼎的<a href="https://en.wikipedia.org/wiki/Reference_counting" rel="external nofollow noopener noreferrer" target="_blank">Reference counting</a>(引用计数)</p><a id="more"></a><h2 id="Reference-counting-的实现原理"><a href="#Reference-counting-的实现原理" class="headerlink" title="Reference counting 的实现原理"></a>Reference counting 的实现原理</h2><p>为每个内存对象分配一个计数器，当一个内存对象建立时计数器初始化为 1(因为此时一定有一个变量引用了该对象)。以后每有一个新变量引用此内存对象（如赋值操作 $a = $b），计数器加 1，而每当减少一个引用此内存对象的变量（如 unset($a)），计数器减 1。当垃圾回收机制运作的时候，将所有计数器为 0 的内存对象销毁并回收其占用的内存。</p><p>在PHP5.2中内存对象就是zval, 计数器就是 zval 的 refcount (PHP5.3之后改成 refcount__gc)， 使用 xdebug 拓展的xdebug_debug_zval() 方法可以看到 refcount 值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">unset($b);</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><p>输出结果<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">b: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure></p><p> 由上而的输出结果到知，当把$a赋值给$b时，refcount 会加 1, 因为两个变量都指向同一个zval, 而不是新增一个zval, 也就是cow(写时复制)。</p><p> 当对$b使用unset()时，refcount 会减 1, 因为现在只有$a指向这个zval。</p><p> Reference counting (引用计数) 非常的简单，但也有一个致命问题，那就是环状引用时会造成内存泄露。</p><p> 如下是一个典型例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = array( &apos;one&apos; );</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br></pre></td></tr></table></figure><p> 输出结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p> 图示:<br> <img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-loop-array.png" alt=""></p><p> 上面的 … 是发生了递归调用, a 的变量容器中 refcount 的值由于有两次引用的存在所以为 2。</p><p> 此时对 $a 调用 unset()，将从符号表中删除这个符号，同时 refcount 值也减 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(refcount=1, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=1, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>图示：</p><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-leak-array.png" alt=""><br>因为 refcount = 1 不等于 0，所以它不会被当作垃圾回收。但同时在符号表中找不到哪个符号指向这个 zval，导致也没有办法手动清除。最终的导致在这个脚本结束之前，这个zval结构体会一直占用着内存，导致内存泄漏。</p><p>由于 Reference Counting 的这个缺陷，PHP5.3 改进了垃圾回收算法。</p><h1 id="PHP5-3中的垃圾回收算法"><a href="#PHP5-3中的垃圾回收算法" class="headerlink" title="PHP5.3中的垃圾回收算法"></a>PHP5.3中的垃圾回收算法</h1><p>PHP5.3 的垃圾回收算法是在引用计数的基础上，添加了一种同步回收算法，这个算法由IBM的工程师在论文<a href="https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf" rel="external nofollow noopener noreferrer" target="_blank">Concurrent Cycle Collection in Reference Counted Systems</a> 中提出。</p><p>具体实现原理:</p><p>首先 PHP 会分配一个固定大小的“根缓冲区”，这个缓冲区用于存放固定数量的 zval（默认是10,000），如果需要修改则需要修改源代码 Zend/zend_gc.c 中的常量 GC_ROOT_BUFFER_MAX_ENTRIES 然后重新编译。</p><p>这个根缓冲区中存放的是 可能根（possible roots)，就是可能发生内存泄露的 zval。当根缓冲区满了的时候（或者手动调用 gc_collect_cycle() 函数时），PHP 就会执行垃圾回收。</p><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-gc-algorithm.png" alt=""></p><h2 id="步骤-A"><a href="#步骤-A" class="headerlink" title="步骤 A"></a>步骤 A</h2><p> 为避免不得不检查所有引用计数可能减少的垃圾周期，这个算法把所有可能根(possible roots 都是zval变量容器),放在根缓冲区(root buffer)中(用紫色来标记，称为疑似垃圾)，这样可以同时确保每个可能的垃圾根(possible garbage root)在缓冲区中只出现一次。仅仅在根缓冲区满了时，才对缓冲区内部所有不同的变量容器执行垃圾回收操作。</p><h2 id="步骤-B"><a href="#步骤-B" class="headerlink" title="步骤 B"></a>步骤 B</h2><p> 模拟删除每个紫色变量。模拟删除时可能将不是紫色的普通变量引用数减”1”，如果某个普通变量引用计数变成0了，就对这个普通变量再做一次模拟删除。每个变量只能被模拟删除一次，模拟删除后标记为灰。</p><h2 id="步骤-C"><a href="#步骤-C" class="headerlink" title="步骤 C"></a>步骤 C</h2><p> 模拟恢复每个紫色变量。恢复是有条件的，当变量的引用计数大于0时才对其做模拟恢复。同样每个变量只能恢复一次，恢复后标记为黑，基本就是步骤 B 的逆运算。这样剩下的一堆没能恢复的就是该删除的蓝色节点了，</p><h2 id="步骤-D"><a href="#步骤-D" class="headerlink" title="步骤 D"></a>步骤 D</h2><p> 清空根缓冲区中的所有根，然后销毁所有 refcount 为 0 的 zval，并收回其内存，这才是真实删除的过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>并不是每次 refcount 减少时都进入回收周期，只有根缓冲区满额后在开始垃圾回收。</li><li>解决了循环引用导致的内存泄露问题。</li><li>整体上可以总将内存泄露保持在一个阈值以下（与缓冲区的大小有关)。</li></ul><h1 id="新的垃圾回收机制总结"><a href="#新的垃圾回收机制总结" class="headerlink" title="新的垃圾回收机制总结"></a>新的垃圾回收机制总结</h1><ul><li>如果发现一个zval容器中的refcount在增加，说明不是垃圾</li><li>如果发现一个zval容器中的refcount在减少，如果减到了0，直接当做垃圾回收</li><li>如果发现一个zval容器中的refcount在减少，并没有减到0，PHP会把该值放到缓冲区，当做有可能是垃圾的怀疑对象</li><li>当缓冲区满时，PHP会自动调用一个方法取遍历每一个值，如果发现是垃圾就清理。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;在阅读本篇博文之前，建议先了解一下: &lt;a href=&quot;/2018/03/06/深入理解PHP内核之ZVAL/&quot;&gt;PHP内核之ZVAL&lt;/a&gt;&lt;br&gt;PHP是一门托管型语言，所以在写PHP代码时无需手动处理内存的分配和释放，也就是说PHP自身实现了垃圾自动回收(GC).&lt;br&gt;在PHP官方你可以看到关于GC的介绍: &lt;a href=&quot;http://php.net/manual/zh/features.gc.php&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;传送&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;PHP5-2中的垃圾回收算法&quot;&gt;&lt;a href=&quot;#PHP5-2中的垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;PHP5.2中的垃圾回收算法&quot;&gt;&lt;/a&gt;PHP5.2中的垃圾回收算法&lt;/h1&gt;&lt;p&gt; 在php5.3之前，PHP使用的内存回收算法是大名鼎鼎的&lt;a href=&quot;https://en.wikipedia.org/wiki/Reference_counting&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Reference counting&lt;/a&gt;(引用计数)&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.i4ww.com/categories/PHP/"/>
    
    
      <category term="PHP zend gc" scheme="http://www.i4ww.com/tags/PHP-zend-gc/"/>
    
  </entry>
  
  <entry>
    <title>深入理解PHP内核之ZVAL</title>
    <link href="http://www.i4ww.com/2018/03/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E5%86%85%E6%A0%B8%E4%B9%8BZVAL/"/>
    <id>http://www.i4ww.com/2018/03/06/深入理解PHP内核之ZVAL/</id>
    <published>2018-03-06T15:55:56.000Z</published>
    <updated>2018-03-07T16:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>PHP是一种弱类型语言，但是弱类型并不代表PHP变量就没有类型区分</p><p>PHP的类型有8种</p><ul><li>标量类型：boolen(布尔)，integer(整型)，float(浮点)，string(字符)</li><li>复合类型：array(数组)，object(对象)</li><li>特殊类型：resource(资源) null</li></ul><a id="more"></a><p>PHP可以不声明变量类型，可以在运行时直接赋值。并且在运行期间可以由一种类型转换成另一种类型。</p><p>如下例，没有声明的情况下，$variable 可以赋任意类型的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$variable = 0;</span><br><span class="line">$variable = &apos;hello world.&apos;;</span><br><span class="line">$variable = true;</span><br></pre></td></tr></table></figure></p><p>在PHP引擎内，变量都是用一个结构体来表示。</p><p>这个结构体具体代码在: <a href="https://github.com/php/php-src/blob/PHP-5.6.34/Zend/zend.h" rel="external nofollow noopener noreferrer" target="_blank">点击传送</a></p><p>ZVAL 基本结构为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">/* Variable information */</span><br><span class="line">zvalue_value value; /* 存储变量的值 */</span><br><span class="line">zend_uint refcount__gc; /* 引用计数 */</span><br><span class="line">zend_uchar type; /* 变量的类型 */</span><br><span class="line">zend_uchar is_ref__gc; /* 是否为引用 */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="zval-value-value"><a href="#zval-value-value" class="headerlink" title="zval_value value"></a>zval_value value</h3><pre><code>这里就是变量的实际值，类型是一个 zvalue_value 联合体。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">long lval;/* long value */</span><br><span class="line">double dval;/* double value */</span><br><span class="line">struct &#123;</span><br><span class="line">char *val;</span><br><span class="line">int len;</span><br><span class="line">&#125; str;</span><br><span class="line">HashTable *ht;/* hash table value */</span><br><span class="line">zend_object_value obj;</span><br><span class="line">zend_ast *ast;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><h3 id="zend-uint-refcount-gc"><a href="#zend-uint-refcount-gc" class="headerlink" title="zend_uint refcount__gc"></a>zend_uint refcount__gc</h3><pre><code>实际是一个计数器，用来保存有多少变量指向该zval。在变量生成时，会置为1，也就是说 refcount__gc = 1对变量进行操作会改变它的值。如 $a = $b 会使 refcount 加 1，而 unset() 操作会减 1</code></pre><h3 id="zend-uchar-type"><a href="#zend-uchar-type" class="headerlink" title="zend_uchar type"></a>zend_uchar type</h3><p> 这个字段表示变量的类型，前面说过 PHP 有8种类型，在 PHP zend 引擎中，对应下面的宏</p><p> 该type字段会决定上面 zval_value 联合体储存的方式</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define IS_NULL0</span><br><span class="line">#define IS_LONG1</span><br><span class="line">#define IS_DOUBLE2</span><br><span class="line">#define IS_BOOL3</span><br><span class="line">#define IS_ARRAY4</span><br><span class="line">#define IS_OBJECT5</span><br><span class="line">#define IS_STRING6</span><br><span class="line">#define IS_RESOURCE7</span><br><span class="line">#define IS_CONSTANT8</span><br><span class="line">#define IS_CONSTANT_AST9</span><br><span class="line">#define IS_CALLABLE10</span><br></pre></td></tr></table></figure><h3 id="zend-uchar-is-ref-gc"><a href="#zend-uchar-is-ref-gc" class="headerlink" title="zend_uchar is_ref__gc"></a>zend_uchar is_ref__gc</h3><pre><code>标志是否为引用,当使用 &amp; 对一个变量操作时,如 $a = &amp;$b, is_ref__gc 会被设置为1。</code></pre><h1 id="zval如何在PHP中运行"><a href="#zval如何在PHP中运行" class="headerlink" title="zval如何在PHP中运行"></a>zval如何在PHP中运行</h1><h3 id="我们在创建一个PHP变量时实际上在PHP中是创建了一个zval"><a href="#我们在创建一个PHP变量时实际上在PHP中是创建了一个zval" class="headerlink" title="我们在创建一个PHP变量时实际上在PHP中是创建了一个zval"></a>我们在创建一个PHP变量时实际上在PHP中是创建了一个zval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 下面代码需要安装 xdebug 扩展</span><br><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h3 id="对应上面的zval结构体，也就是"><a href="#对应上面的zval结构体，也就是" class="headerlink" title="对应上面的zval结构体，也就是"></a>对应上面的zval结构体，也就是</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = &apos;hello world&apos;;</span><br><span class="line">refcount__gc = 1;</span><br><span class="line">type =  IS_STRING;</span><br><span class="line">is_ref__gc = 0;</span><br></pre></td></tr></table></figure><h2 id="我们把-a赋值给另一个变量时，会增加zval的refcount-gc"><a href="#我们把-a赋值给另一个变量时，会增加zval的refcount-gc" class="headerlink" title="我们把$a赋值给另一个变量时，会增加zval的refcount__gc"></a>我们把$a赋值给另一个变量时，会增加zval的refcount__gc</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">xdebug_debug_zval(&apos;b&apos;);</span><br></pre></td></tr></table></figure><h3 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果"></a>输出结果</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">b: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h3 id="可以看到-a和-b的结构是一样的-它们都指向同一个zval"><a href="#可以看到-a和-b的结构是一样的-它们都指向同一个zval" class="headerlink" title="可以看到$a和$b的结构是一样的,它们都指向同一个zval"></a>可以看到$a和$b的结构是一样的,它们都指向同一个zval</h3><h2 id="使用unset时"><a href="#使用unset时" class="headerlink" title="使用unset时"></a>使用unset时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">unset($b);</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输入结果"><a href="#输入结果" class="headerlink" title="输入结果"></a>输入结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=0)=&apos;hello world&apos;</span><br><span class="line">a: (refcount=1, is_ref=0)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h2 id="使用-amp-时"><a href="#使用-amp-时" class="headerlink" title="使用 &amp; 时"></a>使用 &amp; 时</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$a = &apos;hello world&apos;;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br></pre></td></tr></table></figure><h3 id="输入结果-1"><a href="#输入结果-1" class="headerlink" title="输入结果"></a>输入结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=&apos;hello world&apos;</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>  在 PHP7 中，zval结构体发生了重大变化，有兴趣的可以参考 <a href="https://github.com/laruence/php7-internal/blob/master/zval.md" rel="external nofollow noopener noreferrer" target="_blank">鸟哥-深入理解PHP7之zval</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PHP是一种弱类型语言，但是弱类型并不代表PHP变量就没有类型区分&lt;/p&gt;
&lt;p&gt;PHP的类型有8种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标量类型：boolen(布尔)，integer(整型)，float(浮点)，string(字符)&lt;/li&gt;
&lt;li&gt;复合类型：array(数组)，object(对象)&lt;/li&gt;
&lt;li&gt;特殊类型：resource(资源) null&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://www.i4ww.com/categories/PHP/"/>
    
    
      <category term="PHP zend zval" scheme="http://www.i4ww.com/tags/PHP-zend-zval/"/>
    
  </entry>
  
  <entry>
    <title>三种常见单例模式实现</title>
    <link href="http://www.i4ww.com/2018/03/06/%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://www.i4ww.com/2018/03/06/三种常见单例模式实现/</id>
    <published>2018-03-06T14:17:31.000Z</published>
    <updated>2018-03-07T07:14:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="下面列举了三种-懒汉式-饿汉式-登记式"><a href="#下面列举了三种-懒汉式-饿汉式-登记式" class="headerlink" title="下面列举了三种: 懒汉式 饿汉式 登记式"></a>下面列举了三种: 懒汉式 饿汉式 登记式</h3><a id="more"></a><h1 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        if (self::$instance === null) &#123;</span><br><span class="line">            self::$instance = new self();</span><br><span class="line">        &#125;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * php中是不允许这样的，这里只做示例使用</span><br><span class="line">  */</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        return self::$instance;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="登记式"><a href="#登记式" class="headerlink" title="登记式"></a>登记式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * php中是不允许的这样的，这里只做示例使用</span><br><span class="line">  */</span><br><span class="line">class Singleton</span><br><span class="line">&#123;</span><br><span class="line">    private static $instance = null;</span><br><span class="line"></span><br><span class="line">    private function __construct() &#123; &#125;</span><br><span class="line">    private function __clone() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    private static class Holder</span><br><span class="line">    &#123;</span><br><span class="line">        private static final Singleton SINGLETON = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function getInstance() : Singleton</span><br><span class="line">    &#123;</span><br><span class="line">        return Holder.SINGLETON;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;下面列举了三种-懒汉式-饿汉式-登记式&quot;&gt;&lt;a href=&quot;#下面列举了三种-懒汉式-饿汉式-登记式&quot; class=&quot;headerlink&quot; title=&quot;下面列举了三种: 懒汉式 饿汉式 登记式&quot;&gt;&lt;/a&gt;下面列举了三种: 懒汉式 饿汉式 登记式&lt;/h3&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.i4ww.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="单例模式 懒汉式 饿汉式 登记式" scheme="http://www.i4ww.com/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-%E6%87%92%E6%B1%89%E5%BC%8F-%E9%A5%BF%E6%B1%89%E5%BC%8F-%E7%99%BB%E8%AE%B0%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>多版本并发控制的机制与原理</title>
    <link href="http://www.i4ww.com/2018/03/05/%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://www.i4ww.com/2018/03/05/多版本并发控制的机制与原理/</id>
    <published>2018-03-05T11:21:05.000Z</published>
    <updated>2018-03-07T07:08:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-MVCC"><a href="#什么是-MVCC" class="headerlink" title="什么是 MVCC"></a>什么是 MVCC</h1><ul><li>MVCC （Mutli Version Concurreny Control）既 多版本并发控制，也叫 一致性非锁定读，实现原理其它就是使用快照实现写时复制 (Copy On Write)</li></ul><h1 id="使用MVCC的好处"><a href="#使用MVCC的好处" class="headerlink" title="使用MVCC的好处"></a>使用MVCC的好处</h1><ul><li><p>消除锁的开销：传统的数据库保证数据一致性是对数据进行加锁操作，但加锁必然会产生开销，使用MVCC能够避免对数据加锁。</p></li><li><p>提高并发：在保证了数据的ACID的同时，实现了 读读 、读写、写读 的并发。</p></li></ul><a id="more"></a><h1 id="InnoDB如何实现MVCC"><a href="#InnoDB如何实现MVCC" class="headerlink" title="InnoDB如何实现MVCC"></a>InnoDB如何实现MVCC</h1><ul><li>MySql InnoDB MVCC主要是为事务的 可重复读 隔离级别服务的，在此隔离级别下，进程间数据相互隔离。</li><li>为了实现MVCC，InnoDB引擎会对每一行都加上两个隐藏的字段，一个字段用来存储行被更新的时间戳，另一字段存储行被删除的时间戳 （这里的时间戳都是逻辑时间戳）。事务在开始时，InnoDB引擎会给该事务一个递增的版本号（也就是上面说的逻辑时间戳），在该事务中，InnoDB会把每一条语句的版本号和这条语句遇到的行版本进行比对，然后结合不同的隔离级别，来决定是否返回该行。</li></ul><h1 id="MVCC的缺点："><a href="#MVCC的缺点：" class="headerlink" title="MVCC的缺点："></a>MVCC的缺点：</h1><ul><li>为了实现多版本，InnoDB需要维护额外的隐藏字段，以及清理不需要的行版本，会带来额外开销。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><pre><code>MySql技术内幕</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-MVCC&quot;&gt;&lt;a href=&quot;#什么是-MVCC&quot; class=&quot;headerlink&quot; title=&quot;什么是 MVCC&quot;&gt;&lt;/a&gt;什么是 MVCC&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MVCC （Mutli Version Concurreny Control）既 多版本并发控制，也叫 一致性非锁定读，实现原理其它就是使用快照实现写时复制 (Copy On Write)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;使用MVCC的好处&quot;&gt;&lt;a href=&quot;#使用MVCC的好处&quot; class=&quot;headerlink&quot; title=&quot;使用MVCC的好处&quot;&gt;&lt;/a&gt;使用MVCC的好处&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消除锁的开销：传统的数据库保证数据一致性是对数据进行加锁操作，但加锁必然会产生开销，使用MVCC能够避免对数据加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提高并发：在保证了数据的ACID的同时，实现了 读读 、读写、写读 的并发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://www.i4ww.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySql InnoDB MVCC" scheme="http://www.i4ww.com/tags/MySql-InnoDB-MVCC/"/>
    
  </entry>
  
  <entry>
    <title>记一次在Docker容器中crontab不执行的问题</title>
    <link href="http://www.i4ww.com/2018/02/17/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8Docker%E5%AE%B9%E5%99%A8%E4%B8%ADcrontab%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.i4ww.com/2018/02/17/记一次在Docker容器中crontab不执行的问题/</id>
    <published>2018-02-17T10:38:20.000Z</published>
    <updated>2018-03-07T07:09:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决"><a href="#在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决" class="headerlink" title="在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决"></a>在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决</h3><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 进入容器</span><br><span class="line">$ vim /etc/pam.d/crond</span><br><span class="line">account    required   pam_access.so</span><br><span class="line">account    include    password-auth</span><br><span class="line">#session    required   pam_loginuid.so  #注释此行</span><br><span class="line">session    include    password-auth</span><br><span class="line">auth       include    password-auth</span><br></pre></td></tr></table></figure><h1 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h1><ul><li>不要在单一容器中运行超过一个进程</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot;&gt;&lt;a href=&quot;#在容器中添加-crontab-并没有生效，这是由于-docker-容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot; class=&quot;headerlink&quot; title=&quot;在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&quot;&gt;&lt;/a&gt;在容器中添加 crontab 并没有生效，这是由于 docker 容器被严格要求只允许使用内核的部分能力导致的，按下面解决方案修改后解决&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="http://www.i4ww.com/categories/docker/"/>
    
    
      <category term="docker crontab" scheme="http://www.i4ww.com/tags/docker-crontab/"/>
    
  </entry>
  
</feed>
